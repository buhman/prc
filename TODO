prc (core)
==========

TODO
----

### Plugin sandboxing/IPC

A plugin that {segfaults,does invalid/evil things with memory,etc}
also causes prc itself to self-destruct. Instead plugins should run in
their own process and do IPC with prc.

### Big reload

Why stop at reloading plugins? prc could simply hand off socket fds
to a new instance of prc--most of the startup process involves
stateful server-side cruft, so this would effectively reduce full
restart times to ~0 (compared to the current ~5+ second startup
sequence).

### buffer and tag mappings

Incoming protocol messages should be tagged based on match -> tag
mappings that the user creates, and stored in the log database
appropriately.

Similarly, the user should be able to map database tags to buffers,
and the terminal should draw the selected buffer(s) appropriately.

Interleaving multiple tags in the same buffer is also probably
desired, but would require significant modifications to the internal
row linkage format in BDB.

### write queue selection

The terminal should be able to select the write queue (network) that
messages are directed to.

### World Domination

Sandbox
-------

### Global hashtable of hashtables

The global hashtable would be implemented as a singleton--libprc would
implement useful generic access methods. New hashtables would be
created on-the-fly as they are referenced when adding key/value pairs.

### New hashtable implementation

As fun as uthash is, I'm not sure how comfortable I am having ~1,000
lines of code in-tree that I do not maintain. I also don't like
staring at macro expansion errors and having to scroll through miles
of it just to find the real problem.

The buhman-hashtable doesn't even need to be quite as fast, etc.. as
uthash, it just needs to be buhman.

In particular, I would "solve" collision by requiring the verbatim
string be stored in a hashtable datastructure, then compare that to
the original value. dll.c would work well for this purpose.

Plugins
=======

### libquotes

Yet-another key-value database, this time of things people said. This
requires `Add 'buffer' (and logging) support`, in addition to
significant changes to the plugin architecture.

### libfacts

libfacts currently registers `fact_find` and `fact_add`; it would make
negligibly more sense if it registered only `fact`, where said
meta-handler would pass off `find`, `add`, etc...

It may also be desired to allow multiple values for the same key--a
hashtable implementation specifically designed for this would also
make this easier.

### libchess

during draw operations, the state-tracking operations will track
pieces as individual pieces; this allows:

* one-off highlighting of {last-moved piece,possible moves,*}

* possible-move highlighting will predecate move-validation

* move-validation will predicate less-explicit notations and more
  flexible move parsing

* game registration and multiple 'boards'/movesets

* save/restore boards

### libgitcd

In its own special thread, this would wait for a related git
post-commit hook to inform it of new commits; it would then retrieve
said commit message, and regurgitate to the channel.

This would involve an epoll'ed accept()--netcat or similar would be
used in the git post-commit hook, and the initial trivial
implementation would simply involve closing the connection
immediately. libgit2 would then be used to read the HEAD commit.

Because libgitcd would be writing to the plugin queue independently of
the mainloop, the mainloop also needs to be informed of this.

The plugin architecture I think could be updated to provide the
eventfd to the constructor of each plugin. bit-shifting is already
used to encode up to 64 values--a new value for "do the
plugin-write-queue thing" would simply need to be created; perhaps an
enum for these possible events (and their names) should also be
created.

dll also would need to be updated to become threadsafe (should be
trivial).

### libsteal

Interpret '!' commands (directed at phrik), and add whatever phrik
replies with to the factdb.