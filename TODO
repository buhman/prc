prc (core)
==========

TODO
----

### Add 'buffer' (and logging) support

Implementation is planned to be via memory-mapped file access, one
file for each buffer. (Active) buffer output would be not only written
to the terminal, but also to said memory-mapped (log) file.

This also implies the ability to perform complete redraws of contents
upon TE resize events/etc.. in addition to redraws necessary to switch
terminal output between buffers.

### Plugin output; nick-directed

This involves the addition of a new syntax element (with argument(s))
that would rewrite plugin output to do things like 'ping' particular
nicks with plugin output.

This should be implemented by plugin.c, and not by, e.g, each
individual plugin.

### Plugin write queue

Instead of plugins writing arbitrary messages to the real write queue,
it is intended for plugin.c to marshall requests (in order to
accomplish things like the above).

### Plugin command chaining

Create a new syntax element that both allows multiple calls to the
same handler and allows multiple handlers to be called in a single
message (without having to implement similar looping in each plugin
individually).

### Runtime configuration

Currently most "configuration" such as credentials, servers to connect
to, channels to join, etc.. are hard-coded in prc sources; these
rather common things should be moved to a separate runtime-modifiable
configuration file.

### World Domination

Sandbox
-------

### Big reload

Why stop at reloading plugins? prc could simply hand off socket fds
to a new instance of prc--most of the startup process involves
stateful server-side cruft, so this would effectively reduce full
restart times to ~0 (compared to the current ~5+ second startup
sequence).

### sll

sll.c always was a lazy feature-less implementation that hardly did
what I needed at the time. New requirements include full
double-linking, FIFO operations, and arbitrary-index
insertion/deletion.

### Global hashtable of hashtables

The global hashtable would be implemented as a singleton--libprc would
implement useful generic access methods. New hashtables would be
created on-the-fly as they are referenced when adding key/value pairs.

### New hashtable implementation

As fun as uthash is, I'm not sure how comfortable I am having ~1,000
lines of code in-tree that I do not maintain. I also don't like
staring at macro expansion errors and having to scroll through miles
of it just to find the real problem.

The buhman-hashtable doesn't even need to be quite as fast, etc.. as
uthash, it just needs to be buhman.

### Plugin sandboxing/IPC

A plugin that {segfaults,does invalid/evil things with memory,etc}
also causes prc itself to self-destruct. Instead plugins should run in
their own process and do IPC with prc.

Plugins
=======

TODO
----

### libquotes

Yet-another key-value database, this time of things people said. This
requires `Add 'buffer' (and logging) support`, in addition to
significant changes to the plugin architecture.

Sandbox
-------

### libfacts

libfacts currently registers `fact_find` and `fact_add`; it would make
negligibly more sense if it registered only `fact`, where said
meta-handler would pass off `find`, `add`, etc...

### libchess

during draw operations, the state-tracking operations will track
pieces as individual pieces; this allows:

* one-off highlighting of {last-moved piece,possible moves,*}

* possible-move highlighting will predecate move-validation

* move-validation will predicate less-explicit notations and more
  flexible move parsing

* game registration and multiple 'boards'/movesets

* save/restore boards

### libgitcd

In its own special thread, this would wait for a related git
post-commit hook to inform it of new commits; it would then retrieve
said commit messages, and regurgitate to the channel.